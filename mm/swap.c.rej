--- mm/swap.c
+++ mm/swap.c
@@ -254,11 +251,11 @@ void rotate_reclaimable_page(struct page *page)
 		unsigned long flags;
 
 		get_page(page);
-		local_lock_irqsave(rotate_lock, flags);
+		local_irq_save(flags);
 		pvec = this_cpu_ptr(&lru_rotate_pvecs);
 		if (!pagevec_add(pvec, page) || PageCompound(page))
 			pagevec_move_tail(pvec);
-		local_unlock_irqrestore(rotate_lock, flags);
+		local_irq_restore(flags);
 	}
 }
 
@@ -308,13 +305,12 @@ void activate_page(struct page *page)
 {
 	page = compound_head(page);
 	if (PageLRU(page) && !PageActive(page) && !PageUnevictable(page)) {
-		struct pagevec *pvec = &get_locked_var(swapvec_lock,
-						       activate_page_pvecs);
+		struct pagevec *pvec = &get_cpu_var(activate_page_pvecs);
 
 		get_page(page);
 		if (!pagevec_add(pvec, page) || PageCompound(page))
 			pagevec_lru_move_fn(pvec, __activate_page, NULL);
-		put_locked_var(swapvec_lock, activate_page_pvecs);
+		put_cpu_var(activate_page_pvecs);
 	}
 }
 
@@ -336,7 +332,7 @@ void activate_page(struct page *page)
 
 static void __lru_cache_activate_page(struct page *page)
 {
-	struct pagevec *pvec = &get_locked_var(swapvec_lock, lru_add_pvec);
+	struct pagevec *pvec = &get_cpu_var(lru_add_pvec);
 	int i;
 
 	/*
@@ -358,7 +354,7 @@ static void __lru_cache_activate_page(struct page *page)
 		}
 	}
 
-	put_locked_var(swapvec_lock, lru_add_pvec);
+	put_cpu_var(lru_add_pvec);
 }
 
 /*
@@ -400,12 +396,12 @@ EXPORT_SYMBOL(mark_page_accessed);
 
 static void __lru_cache_add(struct page *page)
 {
-	struct pagevec *pvec = &get_locked_var(swapvec_lock, lru_add_pvec);
+	struct pagevec *pvec = &get_cpu_var(lru_add_pvec);
 
 	get_page(page);
 	if (!pagevec_add(pvec, page) || PageCompound(page))
 		__pagevec_lru_add(pvec);
-	put_locked_var(swapvec_lock, lru_add_pvec);
+	put_cpu_var(lru_add_pvec);
 }
 
 /**
@@ -599,15 +595,9 @@ void lru_add_drain_cpu(int cpu)
 		unsigned long flags;
 
 		/* No harm done if a racing interrupt already did this */
-#ifdef CONFIG_PREEMPT_RT
-		local_lock_irqsave_on(rotate_lock, flags, cpu);
+		local_irq_save(flags);
 		pagevec_move_tail(pvec);
-		local_unlock_irqrestore_on(rotate_lock, flags, cpu);
-#else
-		local_lock_irqsave(rotate_lock, flags);
-		pagevec_move_tail(pvec);
-		local_unlock_irqrestore(rotate_lock, flags);
-#endif
+		local_irq_restore(flags);
 	}
 
 	pvec = &per_cpu(lru_deactivate_file_pvecs, cpu);
@@ -643,12 +633,11 @@ void deactivate_file_page(struct page *page)
 		return;
 
 	if (likely(get_page_unless_zero(page))) {
-		struct pagevec *pvec = &get_locked_var(swapvec_lock,
-						       lru_deactivate_file_pvecs);
+		struct pagevec *pvec = &get_cpu_var(lru_deactivate_file_pvecs);
 
 		if (!pagevec_add(pvec, page) || PageCompound(page))
 			pagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);
-		put_locked_var(swapvec_lock, lru_deactivate_file_pvecs);
+		put_cpu_var(lru_deactivate_file_pvecs);
 	}
 }
 
@@ -683,34 +672,23 @@ void mark_page_lazyfree(struct page *page)
 {
 	if (PageLRU(page) && PageAnon(page) && PageSwapBacked(page) &&
 	    !PageSwapCache(page) && !PageUnevictable(page)) {
-		struct pagevec *pvec = &get_locked_var(swapvec_lock,
-						       lru_lazyfree_pvecs);
+		struct pagevec *pvec = &get_cpu_var(lru_lazyfree_pvecs);
 
 		get_page(page);
 		if (!pagevec_add(pvec, page) || PageCompound(page))
 			pagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);
-		put_locked_var(swapvec_lock, lru_lazyfree_pvecs);
+		put_cpu_var(lru_lazyfree_pvecs);
 	}
 }
 
 void lru_add_drain(void)
 {
-	lru_add_drain_cpu(local_lock_cpu(swapvec_lock));
-	local_unlock_cpu(swapvec_lock);
+	lru_add_drain_cpu(get_cpu());
+	put_cpu();
 }
 
 #ifdef CONFIG_SMP
 
-#ifdef CONFIG_PREEMPT_RT
-static inline void remote_lru_add_drain(int cpu, struct cpumask *has_work)
-{
-	local_lock_on(swapvec_lock, cpu);
-	lru_add_drain_cpu(cpu);
-	local_unlock_on(swapvec_lock, cpu);
-}
-
-#else
-
 static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);
 
 static void lru_add_drain_per_cpu(struct work_struct *dummy)
@@ -718,16 +696,6 @@ static void lru_add_drain_per_cpu(struct work_struct *dummy)
 	lru_add_drain();
 }
 
-static inline void remote_lru_add_drain(int cpu, struct cpumask *has_work)
-{
-	struct work_struct *work = &per_cpu(lru_add_drain_work, cpu);
-
-	INIT_WORK(work, lru_add_drain_per_cpu);
-	queue_work_on(cpu, mm_percpu_wq, work);
-	cpumask_set_cpu(cpu, has_work);
-}
-#endif
-
 /*
  * Doesn't need any cpu hotplug locking because we do rely on per-cpu
  * kworkers being shut down before our page_alloc_cpu_dead callback is
@@ -752,20 +720,22 @@ void lru_add_drain_all(void)
 	cpumask_clear(&has_work);
 
 	for_each_online_cpu(cpu) {
+		struct work_struct *work = &per_cpu(lru_add_drain_work, cpu);
 
 		if (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||
 		    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||
 		    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||
 		    pagevec_count(&per_cpu(lru_deactivate_pvecs, cpu)) ||
 		    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||
-		    need_activate_page_drain(cpu))
-			remote_lru_add_drain(cpu, &has_work);
+		    need_activate_page_drain(cpu)) {
+			INIT_WORK(work, lru_add_drain_per_cpu);
+			queue_work_on(cpu, mm_percpu_wq, work);
+			cpumask_set_cpu(cpu, &has_work);
+		}
 	}
 
-#ifndef CONFIG_PREEMPT_RT
 	for_each_cpu(cpu, &has_work)
 		flush_work(&per_cpu(lru_add_drain_work, cpu));
-#endif
 
 	mutex_unlock(&lock);
 }
